# 01 集合类

# 一、实现两个帮助函数

```js
// 帮助函数：它能更好地解释每个方法的功能:接受什么作为输入，返回什么，以及它是否对数组进行了修改。
function logHelper(operateName, array, callback) {
    const input = [...array];
    const result = callback(array);

    console.log({
        operation: operateName,
        arrayBefore: input,
        arrayAfter: array,
        // 是否修改数组
        mutates: mutatesArray(input, array),
        result,
    })
}

// 浅比较判断是否修改了数组 
function mutatesArray(array1, array2) {
    if (array1.length !== array2.length) {
        return true
    }
    for(let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) {
            return true
        }
    }
    return false;
}
```

# 二、forEach

## 1.基本使用

**语法**：

```js
array.forEach(function(currentValue, index, curArr), thisValue)
```

**定义**：用于调用数组的每个元素，并将元素传递给回调函数，没有返回值，原数组不变。

**返回值**：无

**参数**：`callback(currentValue,index,curArr)，thisValue`

**注意**：

+ `forEach()` 对于空数组是不会执行回调函数的。
+ 无法中途退出循环，只能用`return`退出本次回调，进行下一次回调。
+ 它总是返回 undefined值,即使你return了一个值。
+ 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数   
+ 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。    
+ 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。

```js
// arrObj 需要遍历的数组
// item 遍历出的每一个元素
// index 元素对应的下标
// curArr 数组本身
// 无返回值
arrObj.forEach(function(item,index,curArr) {
  console.log(item);
});

let arr = [1, 2, 3, 4];
arr.forEach(item => {
    item = item * 2;
});
console.log(arr); // [1, 2, 3, 4]   原数组保持不变
```

## 2.实现

```js
Array.prototype.myForEach = function (array, callback) {
    for(let i = 0; i < array.length; i++) {
        callback(array[i], i, array)
    }
}
// 调用
logHelper('forEach', [1, 2, 3, 4, 5], array => Array.prototype.myForEach(array, value => console.log(value)));
```

# 三、map

## 1.基本使用

**语法**：

```js
array.map(function(currentValue, index, curArr), thisValue)
```

**定义**：按照原始数组元素顺序依次处理元素。

**返回值**：方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，并没有改变原来的数组。

**参数**：`callback(currentValue,index,curArr)，thisValue`

**注意**：map() 不会对空数组进行检测。

```js
// arrObj 需要遍历的数组
// item 遍历出的每一个元素
// index 元素对应的下标
// curArr 数组本身
// 有返回值
// newArr 新返回的数组
// 数组元素个数不变，但是按照一定的条件转换
arrObj.map(function(item,index,curArr) {
  return item*2;
});

let arr = [1, 2, 3, 4];
let newArr = arr.map(item => {
    return item * 2;
});
console.log(arr); // [1, 2, 3, 4]   原数组保持不变
console.log(newArr); // [2, 4, 6, 8] 返回新数组

```

## 2.实现

```js
Array.prototype.myMap = function (array, callback) {
    const result = [];
    for(let i = 0; i < array.length; i++) {
        result[i] = callback(array[i], i, array);
    }
    return result;
}
```

# 四、filter

## 1.基本使用

**语法**： 

```
array.filter(function(currentValue,index,curArr),thisValue)
```

**定义**：将所有元素进行判断，将满足条件的元素作为一个新的数组返回, 原数组不变。

**返回值**：满足条件的元素作为一个新的数组，并没有改变原来的数组。

**参数**：`callback(currentValue,index,curArr)，thisValue`

**注意**：`filter()` 不会对空数组进行检测。

```js
// arrObj 需要遍历的数组
// item 遍历出的每一个元素
// index 元素对应的下标
// curArr 数组本身
// 有返回值，返回满足某个条件的元素构成的数组
// 数组元素个数可能改变，按照一定的条件返回
arrObj.filter(function(item,index,curArr) {
	return item < 3;
});
let arr = [1, 2, 3, 4];
let newArr = arr.filter(item => {
    return item < 3;
});
console.log(arr); // [1, 2, 3, 4]   原数组保持不变
console.log(newArr); // [1, 2]   返回新数组 
```

## 2.实现

用push避免有空位

```js
Array.prototype.myFilter = function (array, callback) {
    const result = [];
    for (let i = 0; i < array.length; i++) {
        if (callback(array[i], i, array)) {
            result.push(array[i])
        }
    }
    return result
}
```

# 五、reduce

