# 13迭代器&生成器

# 一、迭代器

## 1.迭代

对一组固定的数据结构，按照一定顺序，多次执行某块代码

## 2.为什么需要迭代器

```
数组：.length 遍历
对象：Object.keys
```

不同的数据结构有不同的方法去控制迭代，需要开发人员非常熟悉每个数据接口，因此诞生了迭代器

## 3.迭代器协议（规范）

可以让开发者只关注迭代逻辑，而不必熟悉数据结构，不需要开发者控制循环和结束

```
循环逻辑：
			控制迭代步进，生成迭代值 .next方法，
			next方法返回一个对象{value: xxx, done: false}
			return: 标识是否可以提前退出
终止逻辑：
			next返回下一个迭代值的同时，还会产生一个是否终止的变量
			next方法返回一个对象{value: xxx, done: false}
固有属性：
			由于可能存在一个变量执行多次迭代，每次迭代互不影响
			每个支持可迭代协议的数据类型都保存了一个迭代器构造函数，每次执行不同的迭代时生成新的迭代器
			为了避免冲突和重名，使用了symbol.iterator
			
			
```

## 4.内置可迭代对象

- 可迭代对象协议

  实现了`[Symbol.iterator]`为key的方法，且这个方法返回了一个迭代器对象

- 绕了一大圈终于把概念搞明白了，那可迭代对象有什么好处呢？ 有什么应用场景呢？

  `for of` 的时候，其本质就是调用的这个函数，也就是`[Symbol.iterator]`为`key`的方法

```
字符串
数组
map
set
arguments
NodeList
```

注意：**无对象**

## 5.什么叫支持迭代器模式

支持选代器模式说的并不严谨，指的是在以下操作在实现过程中都可以自动接收可迭代对象，并且自动调用迭代器工厂函数生成迭代器，执行迭代逻辑/ 或者实现遍历

```
for of
数组解构
扩展操作符
Array.from()
创建集合
创建映射
Promise.all
Promise.race
yield* 操作符
```

## 6.查看内置的[Symbol.iterator]方法

```js
const bears = ['ice', 'panda', 'grizzly']
//数组的Symbol.iterator方法
const iter = bears[Symbol.iterator]()

console.log(iter.next())
console.log(iter.next())
console.log(iter.next())
console.log(iter.next())


const nickName = 'ice'
//字符串的Symbol.iterator方法
const strIter = nickName[Symbol.iterator]()

console.log(strIter.next())
console.log(strIter.next())
console.log(strIter.next())
console.log(strIter.next())
```

## 7.实现迭代器

```js
const bears = ['ice', 'panda', 'grizzly']

function createArrIterator(arr) {
  let index = 0

  let _iterator = {
    next() {
      if (index < arr.length) {
        return { done: false, value: arr[index++] }
      }

      return { done: true, value: undefined }
    }
  }

  return _iterator
}

let iter = createArrIterator(bears)

console.log(iter.next())
console.log(iter.next())
console.log(iter.next())
console.log(iter.next())
```

## 8.实现可迭代对象

```js
let info = {
  bears: ['ice', 'panda', 'grizzly'],
  [Symbol.iterator]: function() {
    let index = 0
    let _iterator = {
       //这里一定要箭头函数，或者手动保存上层作用域的this
       next: () => {
        if (index < this.bears.length) {
          return { done: false, value: this.bears[index++] }
        }
  
        return { done: true, value: undefined }
      }
    }

    return _iterator
  }
}

let iter = info[Symbol.iterator]()
console.log(iter.next())
console.log(iter.next())
console.log(iter.next())
console.log(iter.next())

//符合可迭代对象协议 就可以利用 for of 遍历
for (let bear of info) {
  console.log(bear)
}
//ice panda grizzly

```

- 符合可迭代对象协议，是一个对象，有`[Symbol.iterator]`方法，并且这个方法返回了一个迭代器对象。
- 当我利用for of 遍历，就会自动的调用这个方法。

## 9.自定义类迭代实现

```js
class myInfo {
  constructor(name, age, friends) {
    this.name = name
    this.age = age
    this.friends = friends
  }

  [Symbol.iterator]() {
    let index = 0

    let _iterator = {
      next: () => {
        const friends = this.friends
        if (index < friends.length) {
          return {done: false, value: friends[index++]}
        }

        return {done: true, value: undefined}
      }
    }

    return _iterator
  }
}

const info = new myInfo('ice', 22, ['panda','grizzly'])

for (let bear of info) {
  console.log(bear)
}

//panda
//grizzly
```

## 10.为什么forEach不支持提前终止

# 二、生成器

https://zhuanlan.zhihu.com/p/216060145

## 1.定义

箭头函数无法定义生成器

<img src="https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008234231072.png" alt="image-20231008234231072" style="zoom:25%;" />

返回值是一个生成器对象，实现了迭代器协议，是一个特殊的迭代器

## 2.迭代器和生成器的区别

生成器可以使用return、throw结束迭代

迭代器对象是在数据结构的迭代器构造函数中声明

![image-20231008234808938](https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008234808938.png)

生成器的next的返回值在生成器中定义

![image-20231008234912734](https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008234912734.png)

+ 如果没有return 返回 `{done: true, value: undefined}`
+ 如果有return 则value=return语句的返回值

## 3.为什么需要yield

return语句只能调用一次，如果要对生成器对象调用多次next就无法使用，这样就诞生了yield，只能在生成器中使用的高级return

+ 执行到yield，返回yield后面的值，暂停，保留上下文
+ 再次调用next走到下一个yield

## 4.把生成器对象当做可迭代对象去迭代

<img src="https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008235548590.png" alt="image-20231008235548590" style="zoom: 25%;" />

<img src="https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008235735481.png" alt="image-20231008235735481" style="zoom:25%;" />

## 5.yield作为函数中间参数

![image-20231008235835722](https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008235835722.png)

![image-20231008235854336](https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231008235854336.png)

<img src="https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231009000208547.png" alt="image-20231009000208547" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231009000335854.png" alt="image-20231009000335854" style="zoom:25%;" />

## 6.yield*迭代

![image-20231009000505545](https://cdn.jsdelivr.net/gh/zhuling904/DrawingBed/imgMac/image-20231009000505545.png)