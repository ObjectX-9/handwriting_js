<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        class Scheduler {

            constructor(max) {
                this.max = max
                this.count = 0;
                this.queue = []
            }


            async add(promiseCreator) {
                // promiseCreator返回是一个promise
                console.log("✅ ~ promiseCreator:", promiseCreator)
                // 这里使用await，是因为需要等待promiseCreator返回的promise执行完毕，才能执行下一步
                if (this.count >= this.max) {
                    // 如果当前任务数大于最大任务数，则将当前任务阻塞，等待队列中的任务执行完毕，再执行当前任务
                    await new Promise((resolve, reject) => {
                        this.queue.push(resolve)
                    })
                }
                // 当前任务数加1
                this.count++;

                // 执行当前任务
                let res = await promiseCreator()
                // 任务执行完毕

                // 任务执行完，需要去队列中获取新的任务开始执行，新的任务被阻塞了，因为resolve没执行，所以需要手动执行resolve
                // 手动resolve之后，会继续未完成的任务
                if (this.queue.length) {
                    const topQueue = this.queue.shift();
                    // 唤醒阻塞的任务
                    topQueue()
                }

                // 当前任务数减1
                this.count--;

                return res;
            }
        }

        const timeout = (time) => new Promise(resolve => {
            setTimeout(resolve, time)
        })

        const scheduler = new Scheduler(2)
        const addTask = (time, order) => {
            scheduler
                .add(() => {
                    const res = timeout(time)
                    return res
                })
                .then(() => console.log(order))
        }

        addTask(1000, '1')  // 任务1
        addTask(500, '2') // 任务2
        addTask(300, '3') // 任务3
        addTask(400, '4')  // 任务4

        // 打印顺序是：2 3 1 4

    </script>

</body>

</html>