<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        Promise.race = function (promises) {
            if (!Array.isArray(promises)) {
                throw new TypeError('promises must be an array')
            }

            // 这里没有处理promises是空数组的情况是因为，迭代是空的话promise永远为pending状态，不会执行resolve和reject

            return new Promise((resolve, reject) => {
                for (let i = 0; i < promises.length; i++) {
                    Promise.resolve(promises[i]).then(res => {
                        resolve(res)
                        return
                    }, reason => {
                        reject(reason)
                        return
                    })
                }
            })
        }

        // 数组全是非Promise值，测试通过
        let p1 = Promise.race([1, 3, 4]);
        setTimeout(() => {
            console.log('p1 :>> ', p1);
        });

        // 空数组，测试通过
        let p2 = Promise.race([]);
        setTimeout(() => {
            console.log('p2 :>> ', p2);
        });

        const p11 = new Promise((resolve, reject) => {
            setTimeout(resolve, 500, 'one');
        });

        const p22 = new Promise((resolve, reject) => {
            setTimeout(resolve, 100, 'two');
        });

        // // 数组里有非Promise值，测试通过
        Promise.race([p11, p22, 10]).then((value) => {
            console.log('p3 :>> ', value);
            // Both resolve, but p22 is faster
        });
        // expected output: 10

        // 数组里有'已解决的Promise' 和 非Promise值 测试通过
        let p12 = Promise.resolve('已解决的Promise')
        setTimeout(() => {
            Promise.race([p12, p22, 10]).then((value) => {
                console.log('p4 :>> ', value);
            });
            // expected output:已解决的Promise
        });

        // Promise.race的一般情况 测试通过
        const p13 = new Promise((resolve, reject) => {
            setTimeout(resolve, 500, 'one');
        });

        const p14 = new Promise((resolve, reject) => {
            setTimeout(resolve, 100, 'two');
        });

        Promise.race([p13, p14]).then((value) => {
            console.log('p5 :>> ', value);
            // Both resolve, but promise2 is faster
        });
        // expected output: "two"
    </script>
</body>

</html>