# 01防抖&节流

# 一、防抖

## 1.应用

用于限制在短时间内频繁触发某个事件的执行次数。这种情况通常出现在用户在一个连续操作中多次触发同一事件，例如快速连续点击按钮、滚动页面时频繁触发事件等。

## 2.原理

防抖的基本思想是在事件触发后，设定一个等待时间（也称为延迟时间），只有在等待时间内没有再次触发该事件，才执行事件的回调函数。如果在等待时间内再次触发了该事件，就会重新计时等待时间。这样可以有效地阻止事件频繁触发，减少不必要的处理开销，提升前端性能和用户体验。

在实现防抖时，可以通过使用定时器（setTimeout）和清除定时器（clearTimeout）来实现。每次触发事件时，先清除之前设置的定时器，再设置一个新的定时器，从而达到防抖的效果。

## 3.手写

- 进入函数清除定时器
- debounce返回一个函数
- 清除函数后重置定时器
- 可以给函数传递参数

```js
// 设置防抖
function debounce(callback, delay) {
  let timer = null;
  // debounce返回一个函数，进入先清空定时器，然后重置定时器
  return function () {
    // 清除定时器
    clearTimeout(timer);
    // 重置定时器
    timer = setTimeout(() => {
      callback(delay);
    }, delay);
  };
}
```

# 二、节流

## 1.应用

- 页面滚动事件：当用户滚动页面时，会频繁触发滚动事件。使用节流可以限制滚动事件的触发频率，避免过多的滚动事件处理，从而提高页面性能。
- 窗口大小调整事件：当用户调整浏览器窗口大小时，会频繁触发窗口大小调整事件。使用节流可以确保调整事件在一定时间间隔内只触发一次，避免过多的计算和布局更新。
- 输入框输入事件：当用户在输入框中输入内容时，每输入一个字符都会触发输入事件。使用节流可以控制输入事件的触发频率，减少输入事件的处理次数，特别适用于实时搜索功能。
- 鼠标移动事件：当鼠标在页面上移动时，会频繁触发鼠标移动事件。使用节流可以限制鼠标移动事件的触发次数，避免过多的计算和渲染。
- 按钮点击事件：当用户频繁点击按钮时，使用节流可以确保按钮点击事件在一定时间间隔内只触发一次，避免多次点击导致的重复操作。
- 自动完成（Autocomplete）功能：在输入框中实现自动完成功能时，用户每输入一个字符就会触发一次搜索请求。使用节流可以限制搜索请求的触发频率，避免频繁的搜索请求。
- 拖拽操作：当用户进行拖拽操作时，拖拽事件会持续触发。使用节流可以限制拖拽事件的触发频率，避免频繁的拖拽事件处理。

## 2.原理

不同于防抖，节流是确保在一定时间间隔内，事件最多触发一次，而不是在等待时间结束时执行一次。

节流函数的基本思想是，在事件触发后立即执行一次事件处理函数，并且在接下来的一段时间内阻止再次触发事件。只有在经过指定的时间间隔后，才允许再次触发事件，再次执行事件处理函数。

## 3.手写

+ 先判断是否可以执行
+ 阻止执行
+ 执行函数
+ 延迟时间设置为可执行

```js
function throttle(callback) {
  let canRun = true;
  return function () {
    // 已经有一个执行了，返回
    if (!canRun) return;
    // 阻止执行
    canRun = false;
    // 执行函数
    callback("我节流了");
    // 设置间隔时间
    setTimeout(() => {
      canRun = true;
    }, 1000);
  };
}
```

# 参考文档

[1.防抖节流](https://juejin.cn/post/6844903795420299278?searchId=20230724101944481221A684A88D8B7900#heading-2)

