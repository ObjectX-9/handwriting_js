# 二叉树

如果树中每个节点最多只能有两个子节点, 这样的树就成为"二叉树".

## 二叉树的概念

二叉树的定义

- 二叉树可以为空, 也就是没有结点.
- 若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。

二叉树有五种形态:

- 注意c和d是不同的二叉树, 因为二叉树是有左右之分的.

![img](./assets/webp-20240401220556609)

## 二叉树的特性

一个二叉树第 i 层的最大结点数为：`2^(i-1), i >= 1`;

深度为k的二叉树有最大结点总数为： `2^k - 1, k >= 1`;

对任何非空二叉树 T，若n0表示叶结点的个数、n2是度为2的非叶结点个数，那么两者满足关系`n0 = n2 + 1`。

![img](./assets/webp-20240401220631452)

## 特性推导

### 一个二叉树第 i 层的最大结点数为：`2^(i-1), i >= 1`;

二叉树是每个节点最多有两个子节点的树结构，通常被称作左子节点和右子节点。在二叉树的第 i 层（根节点为第一层），每一层的最大节点数可以递归地定义为上一层节点数的两倍。这是因为在完美二叉树（Perfect Binary Tree）中，每个节点都有两个子节点。

我们可以用数学归纳法来推理：

1. 基础情况：
   当 i = 1 时，即树的第一层，只有根节点。因此，第一层的最大结点数为 1，这也符合 `2^(1-1) = 2^0 = 1`。
2. 归纳假设：
   假设在第 k 层（其中 k >= 1），最大结点数为 `2^(k-1)`。
3. 归纳步骤：
   接下来需要证明在第 k+1 层，最大结点数为 `2^k`。

由于二叉树的定义，每个节点最多有两个子节点，那么如果第 k 层已经达到最大结点数 `2^(k-1)`，那么第 k+1 层每个节点都会有两个子节点。因此，第 k+1 层的最大结点数将是第 k 层的两倍。

我们将第 k 层的最大结点数乘以 2 ，得到第 k+1 层的最大节点数：

```
2 * (最大结点数在第 k 层) = 2 * 2^(k-1) = 2^1 * 2^(k-1) = 2^(k+1-1) = 2^k
```

因此，第 k+1 层的最大结点数确实是 `2^k`。

所以，根据这个归纳步骤，我们可以证明对任何 i >= 1，第 i 层的最大结点数都是 `2^(i-1)`。这正是我们要证明的结果。

### 深度为k的二叉树有最大结点总数为： `2^k - 1, k >= 1`;

深度为 k 的二叉树有最大结点总数为 `2^k - 1`：

- **基础情况：** 当 k=1 时，树只有一个结点（根节点），所以总结点数为 1，即 `2^1 - 1 = 2 - 1 = 1`，公式成立。
- **归纳假设：** 假设对于某个正整数 n，深度为 n 的二叉树有最大结点总数为 `2^n - 1` 成立。
- **归纳步骤：** 考虑深度为 n+1 的二叉树，**根据性质1，第 n+1 层的最大结点数为 `2^n`**。而前 n 层的最大结点总数为 `2^n - 1`。所以深度为 n+1 的二叉树的最大结点总数为 `2^n + (2^n - 1) = 2*2^n - 1 = 2^(n+1) - 1`。因此，深度为 n+1 的二叉树有最大结点总数为 `2^(n+1) - 1`，公式成立。
- 根据数学归纳法，对于所有的正整数 k，深度为 k 的二叉树有最大结点总数为 `2^k - 1`。

### 对于任何非空二叉树 T，叶结点的个数 n0 与度为 2 的非叶结点个数 n2 满足关系 `n0 = n2 + 1`

要证明对于任何非空二叉树T，n0（叶节点的个数）和n2（度数为2的非叶节点的个数）满足关系`n0 = n2 + 1`，我们可以类似地使用归纳法来推导：

在二叉树中，节点的度数指的是该节点拥有的子节点数量。除了叶节点（度数为0）和度数为2的节点，还有可能有度数为1的节点（即只有一个子节点的非叶节点）。

设n1表示度数为1的非叶节点数量，总节点数n可以表示为：

```plaintext
n = n0 + n1 + n2
```

在二叉树中，总的边数e（也就是父子关系的数目）是总节点数减1，因为除了根节点，每个节点有一个父节点：

```plaintext
e = n - 1 = n0 + n1 + n2 - 1
```

另一方面，总边数也可以根据节点的度数来计算。每个度为1的节点贡献了1条边，每个度为2的节点贡献了2条边。叶节点（度数为0）不贡献边，所以总边数也可以表示为：

```plaintext
e = n1 + 2*n2
```

由于这两种情况描述的是同一个树的总边数，它们必须相等，所以我们有：

```plaintext
n0 + n1 + n2 - 1 = n1 + 2*n2
```

整理这个等式，我们得到：

```plaintext
n0 = n2 + 1
```

这就是需要证明的关系。

另一种更直观的解释方法是：

- 树中每添加一个度为2的节点，会增加2个子节点。
- 这两个子节点中，一个会成为新的叶节点，而另一个则取代了原有的叶节点的位置。
- 因此，每次增加一个度为2的节点，叶节点的数量增加的数量总比度数为2的节点的数量多1。
- 一个只有根节点的树将会有1个叶节点（根节点本身）且没有度数为2的节点，提供了这个性质的基础情况。
- 当树逐渐增长，上述性质保持不变，因为叶节点和度数为2的节点之间总是保持n0 = n2 + 1的关系。

## 特殊的二叉树

完美二叉树(Perfect Binary Tree) , 也称为满二叉树(Full Binary Tree）

- 在二叉树中, 除了最下一层的叶结点外, 每层节点都有2个子结点, 就构成了满二叉树.

![img](./assets/webp-20240401223047715)

完全二叉树(Complete Binary Tree)

- 除二叉树最后一层外, 其他各层的节点数都达到最大个数.
- 且最后一层从左向右的叶结点连续存在, 只缺右侧若干节点.
- 完美二叉树是特殊的完全二叉树.

下面不是完全二叉树, 因为D节点还没有右结点, 但是E节点就有了左右节点.

![img](./assets/webp-20240401223114117)



## 二叉树的存储

- 二叉树的存储常见的方式是数组和链表.

### 使用数组存储:

- 完全二叉树: 按从上至下、从左到右顺序存储

![img](./assets/webp-20240401223208342)

+ 非完全二叉树:

  + 非完全二叉树要转成完全二叉树才可以按照上面的方案存储.

  - 但是会造成很大的空间浪费

![img](./assets/webp-20240401223332186)

### 链表存储

- 二叉树最常见的方式还是使用链表存储.
- 每个结点封装成一个Node, Node中包含存储的数据, 左结点的引用, 右结点的引用.

![img](./assets/webp-20240401223441645)